Event Handling
--------------

UI isn't static. Instead the user interacts with it, generating _events_ which update the UI and
potentially the app _state_.  Fluxx supports two kinds of event handling:

1. Traditional callbacks, where you write imperative code behind (say in C#) that's called
   immediately when the a UI event occurs.
2. Declarative event handling, where you state declaratively what kind of state update should occur.

# Traditional callbacks and code behind

The declarative approach is preferred, but traditional callbacks make it easy to move existing UI to
Fluxx and handle some more complex scenarios.

For an example, let's start with some Xamarin Forms XAML and and C# code behind, as may be used today.

First the XAML:

`RainingPage.xaml`
```
<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="CatsAndDogs.Views.RainingPage"
             Title="Raining">
  <ScrollView>
    <StackLayout Padding="10">
      <Label Text="What's the weather?" FontSize="40"/>
      <Button x:Name="MoreRain"  Text="Click Me" Clicked="MoreRain_Clicked"/>
      <Label x:Name="WeatherLabel"/>
    </StackLayout>
  </ScrollView>
</ContentPage>
```

And here's the code behind.  Clicking the button bumps a counter which updates the message text.

`RainingPage.xaml.cs`
```
using System;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace CatsAndDogs.Views
{
    public partial class RainingPage : ContentPage
    {
        int count = 0;

        public RainingPage() {
            InitializeComponent();
            updateWeather();
        }

        private void MoreRain_Clicked(object sender, EventArgs e) {
            ++count;
            updateWeather();
        }

        private void updateWeather() {
            if (count == 0) {
                WeatherLabel.Text = "It's not raining.";
            }
            else {
                WeatherLabel.Text = $"It's raining {count} cats and dogs.";
            }
        }
    }
}
```

That page is instantiated somewhere, say when it's first displayed, with code like this:
```
new RainingPage();
```

XAML does code generation, so for completeness here's the generated code from the XAML:
```
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CatsAndDogs.Views {
    using System;
    using Xamarin.Forms;
    using Xamarin.Forms.Xaml;
    
    
    public partial class RainingPage : global::Xamarin.Forms.ContentPage {
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("Xamarin.Forms.Build.Tasks.XamlG", "0.0.0.0")]
        private global::Xamarin.Forms.Button MoreRain;
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("Xamarin.Forms.Build.Tasks.XamlG", "0.0.0.0")]
        private global::Xamarin.Forms.Label WeatherLabel;
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("Xamarin.Forms.Build.Tasks.XamlG", "0.0.0.0")]
        private void InitializeComponent() {
            this.LoadFromXaml(typeof(RainingPage));
            MoreRain = this.FindByName<global::Xamarin.Forms.Button>("MoreRain");
            WeatherLabel = this.FindByName<global::Xamarin.Forms.Label>("WeatherLabel");
        }
    }
}
```

Now here's the Fluxx version, using the same traditional callbacks and code behind.

`RainingPage.fx`

```
<RainingPage/> =>
    <ContentPage Title=Raining
      <StackLayout Padding=10
        <Label Text:What's the weather?; FontSize=24 />
        <Button Name=MoreRain; Text=Click Me; Clicked=MoreRain_Clicked />
        <Label Name=WeatherLabel />
      /StackLayout>
    /ContentPage>
```

And here's the code behind, very similar to the XAML version.

`RainingPage.fx.cs`
```
using System;
using Xamarin.Forms;
using Xamarin.Forms.Xaml;

namespace CatsAndDogs.Views {

    public partial class RainingPage
    {
        int count = 0;
        RainingPage rainingPage;

        public RainingPage() {
            updateWeather();
        }

        private void MoreRain_Clicked(object sender, EventArgs e) {
            ++count;
            updateWeather();
        }

        private void updateWeather() {
            if (count == 0) {
                rainingPage.WeatherLabel.Text = "It's not raining.";
            }
            else {
                rainingPage.WeatherLabel.Text = $"It's raining {count} cats and dogs.";
            }
        }
    }
}
```

If Fluxx sees an event handler used without a qualifier
(`Clicked=MoreRain_Clicked` above as opposed to say `Clicked=myOtherClass.MoreRain_Clicked`) then it assumes
the event handler is defined in a code behind class, named the same as the function name.  An editor with Fluxx
support can validate all of that at edit time. Again, Fluxx is strongly typed.

The page is instantiated when first displayed with code like this:
```
new RainingPage();
```
Fluxx under the covers instantiates the code behind class, if there is one for the page.

Finally, Fluxx does code generation, like XAML. The generated code is similar to the XAML, but there are a few differences. First, the control references (generated for any object with a Name) are public instead of private. That's more of a functional style and allows use of those properties from any class. Also note that if the Fluxx function takes parameters they beconme constructor parameters here. If there's a view model, for instance, it's
normally passed as a parameter--or multiple parameters.

# Declarative event handling

I need to document this more, but with declarative event handling the idea that you express
declaratively what kind of state updates should occur in response to an event, with no imperative
(C#) code necessarily required.

A common scenario is navigation:

```
<Page1/> =>
    <ContentPage 
      <StackLayout Padding=10
        <Button Text=Next Page; Clicked=<Navigate <Page2 pageTitle=This is the title/> /> />
      /StackLayout>
    /ContentPage>

<Page2 pageTitle:UIText/> =>
    <ContentPage Title=@pageTitle
      <StackLayout Padding=10
        <Label Here's the new page!/>
        <Label It has a customized title, passed as an argument./>
      /StackLayout>
    /ContentPage>
```

`Navigate` says what page should be displayed when the specified event happens, including any parameters.

Note that when the `Navigate` expression is evaluated it doesn't actually do the navigate as a side
effect. A a functional language, Fluxx expressions don't have side effects. Instead `Navigate` is a
declarative definition of what should happen when the button is clicked. It's up to some "driver
code" to dispatch the events, look up what's supposed to happen in response to them, and then apply
those actions.

One goal of Fluxx is that it should be possible to build working UI prototypes without writing any
code. That makes it easy for designers and other semi-technical folks to prototype UI. Navigation is
obviously an important part of a UI prototype, and declarative navigation enables that, plus makes
navigation easier when building real apps too.

As for declaratively expressing other kinds of state updates, I'm still thinking through the
possibilities there and need to do a write up once I settle on a proposed scheme.  But in terms of
goals, I'd like to allow easy support for "local state" for a UI component (a UI component is
function in Fluxx) as well as global state of the app. React Native has kind of a similar concept of
local component state and global state.  Update: I have a scheme in mind now for local UI component
state; it's pretty good, I think, but I still need to write it up.

Also of note, both React Native and Elm encourage the model of managed state, where app state is
only updated in well-specified ways.  That allows functionality like time travel debugging, rolling
state back, reactivity when state updates occur, and other benefits. I'd like to move to enabling
(but not requiring) this managed state model more in C# apps.
